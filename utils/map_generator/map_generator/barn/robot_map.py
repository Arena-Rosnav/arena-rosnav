import queue as q
from typing import List, Tuple

from .a_star import AStarSearch


class RobotMap:
    """
    Represents a robot map generated from an occupancy map.

    Attributes:
        ob_map (List[List[int]]): The occupancy map generated by ObstacleMap.
        radius_extra_cells (int): The number of cells the robot takes up in each direction in addition.
        infl_rad_cells (int): The number of cells for inflation radius.

    Methods:
        __init__(ob_map: List[List[int]], radius_extra_cells: int, infl_rad_cells: int): Initializes the RobotMap object.
        _get_region(r: int, c: int) -> Tuple[List[List[int]], int]: Uses the flood-fill algorithm to find the open region including (r, c).
        biggest_left_region() -> List[List[int]]: Returns the largest contiguous region with a tile in the leftmost column.
        biggest_right_region() -> List[List[int]]: Returns the largest contiguous region with a tile in the rightmost column.
        regions_connected(regionA: List[List[int]], regionB: List[List[int]]) -> bool: Checks if two regions are connected.
        get_path(points: List[Tuple[int, int]], dist_map) -> List[Tuple[int, int]]: Returns a path between all points using A* algorithm.
        _jmap_from_obs_map(robot_radius: int) -> List[List[int]]: Generates a Jackal map from the obstacle map.
        _open(row: int, col: int, robot_radius: int) -> bool: Checks if the robot center can be located at (row, col).
        _in_map(r: int, c: int) -> bool: Checks if the given coordinates are within the map boundaries.
        get_map() -> List[List[int]]: Returns the robot map.
    """

    def __init__(
        self, ob_map: List[List[int]], radius_extra_cells: int, infl_rad_cells: int
    ):
        self.ob_map = ob_map
        self.rows = len(ob_map)
        self.cols = len(ob_map[0])

        self.map = self._jmap_from_obs_map(radius_extra_cells)
        self.infl_rad_cells = infl_rad_cells

    # use flood-fill algorithm to find the open region including (r, c)
    def _get_region(
        self, r: List[List[int]], c: List[List[int]]
    ) -> Tuple[List[List[int]], int]:
        """
        Get the open region connected to the given coordinates (r, c).

        Args:
            r (List[List[int]]): The row coordinates.
            c (List[List[int]]): The column coordinates.

        Returns:
            Tuple[List[List[int]], int]: A tuple containing the open region 2D array and its size.
        """
        queue = q.Queue(maxsize=0)

        # open region 2D array that indicates the
        # open region connected to (r, c) with a 1
        region = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        size = 0

        if self.map[r][c] == 0:
            queue.put((r, c))
            region[r][c] = 1
            size += 1

        while not queue.empty():
            coord_r, coord_c = queue.get()

            # check four cardinal neighbors
            for i in range(coord_r - 1, coord_r + 2):
                for j in range(coord_c - 1, coord_c + 2):
                    if self._in_map(i, j) and (i == coord_r or j == coord_c):
                        # if empty space and not checked yet
                        if self.map[i][j] == 0 and region[i][j] == 0:
                            # add to region and put in queue
                            region[i][j] = 1
                            queue.put((i, j))
                            size += 1

        return region, size

    # returns the largest contiguous region with a tile in the leftmost column
    def biggest_left_region(self):
        """
        Finds the biggest region on the left side of the map.

        Returns:
            list: The biggest region on the left side of the map.
        """
        max_size = 0
        max_region = []
        for row in range(self.rows):
            region, size = self._get_region(row, 0)

            if size > max_size:
                max_size = size
                max_region = region

        return max_region

    # returns the largest contiguous region with a tile in the rightmost column
    def biggest_right_region(self):
        """
        Finds the biggest region on the right side of the map.

        Returns:
            list: The biggest region on the right side of the map.
        """
        max_size = 0
        max_region = []
        for row in range(self.rows):
            region, size = self._get_region(row, self.cols - 1)

            if size > max_size:
                max_size = size
                max_region = region

        return max_region

    def regions_connected(self, regionA: List[List[int]], regionB: List[List[int]]):
        """
        Check if two regions are connected.

        Args:
            regionA (List[List[int]]): The first region represented as a 2D list of integers.
            regionB (List[List[int]]): The second region represented as a 2D list of integers.

        Returns:
            bool: True if the regions are connected, False otherwise.
        """
        for r in range(len(regionA)):
            for c in range(len(regionA[0])):
                if regionA[r][c] != regionB[r][c]:
                    return False

                # if they share any common spaces, they're connected
                elif regionA[r][c] == 1 and regionB[r][c] == 1:
                    return True

        return False

    # returns a path between all points in the list points using A*
    # if a valid path cannot be found, returns None
    def get_path(self, points, dist_map):
        """
        Generates a path between a list of points on the map.

        Args:
            points (list): A list of points on the map.
            dist_map (list): A distance map used for path planning.

        Returns:
            list: The overall path between the points.
        Raises:
            Exception: If the path needs at least two points.
            Exception: If any of the points are walls.
        """
        num_points = len(points)
        if num_points < 2:
            raise Exception("Path needs at least two points")

        # check if any points aren't empty
        for point in points:
            if self.map[point[0]][point[1]] == 1:
                raise Exception("The point (%d, %d) is a wall" % (point[0], point[1]))

        overall_path = []
        for n in range(num_points - 1):
            overall_path.append(points[n])

            # generate path between this point and the next one in the list
            a_star = AStarSearch(self.map, self.infl_rad_cells)

            intermediate_path = a_star(points[n], points[n + 1], dist_map)
            if not intermediate_path:
                return None

            # add to the overall path
            if n > 0:
                intermediate_path.pop(0)
            overall_path.extend(intermediate_path)

        return overall_path

    # robot_radius is how many cells from the center cell the robot takes up
    # robot_radius of 1 means robot takes up 3x3 cells
    # robot_radius of 2 means robot takes up 5x5 cells
    def _jmap_from_obs_map(self, robot_radius: int):
        """
        Generates a Jackal map from the obstacle map.

        Args:
            robot_radius (int): The radius of the robot.

        Returns:
            list: A 2D list representing the Jackal map, where 0 represents open space and 1 represents obstacles.
        """
        jackal_map = [[0 for _ in range(self.cols)] for _ in range(self.rows)]

        for r in range(self.rows):
            for c in range(self.cols):
                if not self._open(r, c, robot_radius):
                    jackal_map[r][c] = 1
        return jackal_map

    # checks robot_radius cells outward from (r, c)
    # returns true if robot center can be located at (r, c)
    def _open(self, row, col, robot_radius):
        """
        Check if a given position is open for the robot to move.

        Args:
            row (int): The row index of the position.
            col (int): The column index of the position.
            robot_radius (int): The radius of the robot.

        Returns:
            bool: True if the position is open, False otherwise.
        """
        for r in range(row - robot_radius, row + robot_radius + 1):
            for c in range(col - robot_radius, col + robot_radius + 1):
                if self._in_map(r, c) and self.ob_map[r][c] == 1:
                    return False

        return True

    def _in_map(self, r, c):
        """
        Check if the given row and column coordinates are within the map boundaries.

        Args:
            r (int): The row coordinate.
            c (int): The column coordinate.

        Returns:
            bool: True if the coordinates are within the map boundaries, False otherwise.
        """
        return 0 <= r and r < self.rows and 0 <= c and c < self.cols

    def get_map(self):
        return self.map
